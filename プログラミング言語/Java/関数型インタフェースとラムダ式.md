## 自分
Javaで用意されている関数型インタフェースとその役割を列挙してください。

## AI Assistant
はい、Javaには標準で多数の関数型インタフェースが用意されています。代表的なものとその役割を一覧でまとめます。

---

### Java 標準の主な関数型インタフェース

| インタフェース         | 引数          | 戻り値     | 用途・役割                                 |
|-----------------------|---------------|------------|--------------------------------------------|
| **`Predicate<T>`**    | T             | boolean    | 条件判定（テスト用関数）                   |
| **`Consumer<T>`**     | T             | void       | 消費処理（受け取り、値を使うが返さない）   |
| **`Supplier<T>`**     | なし          | T          | 供給処理（値を作って返す）                 |
| **`Function<T,R>`**   | T             | R          | 変換処理（TをRに変換して返す）             |
| **`UnaryOperator<T>`**| T             | T          | T型同士の一項変換（Function<T, T>の特化）  |
| **`BinaryOperator<T>`**| T, T         | T          | 2つのTを合成してTを返す（Function<T, T, T>の特化）|

### 発展・補助的な関数型インタフェース

| インタフェース            | 説明                                     |
|--------------------------|------------------------------------------|
| **`BiPredicate<T, U>`**  | 2つの値を判定しbooleanを返す             |
| **`BiConsumer<T, U>`**   | 2つの値を消費処理                        |
| **`BiFunction<T, U, R>`**| 2つの値からR型の値を生成                  |
| **`DoubleSupplier`/`IntSupplier`など** | プリミティブ型用のSupplier              |
| **`ToIntFunction<T>`**   | Tからint値を返す関数                     |
| **`ObjIntConsumer<T>`**  | オブジェクトTとint、2つの値を消費処理    |
| **`BooleanSupplier`**    | booleanを返すサプライヤ                  |

---

### 使用例

```java
// Predicateの例
Predicate<String> isEmpty = String::isEmpty;

// Consumerの例
Consumer<String> printer = System.out::println;

// Supplier の例
Supplier<Double> randomSupplier = Math::random;

// Functionの例
Function<String, Integer> stringLength = String::length;

// UnaryOperatorの例
UnaryOperator<String> toUpper = String::toUpperCase;

// BinaryOperatorの例
BinaryOperator<Integer> sum = (a, b) -> a + b;
```


---

#### 補足

- これらは `java.util.function` パッケージに含まれています。
- これ以外にもプリミティブ型専用のインタフェースもあります（例：`IntPredicate`、`DoubleConsumer`など）。

詳しく知りたい型があれば個別に解説できますので、お気軽にどうぞ！

## 自分
示してもらったインタフェースを、実際にラムダ式で使用する例を示してください。

## AI Assistant
もちろんです！以下に、先ほど挙げた主な関数型インタフェースを**ラムダ式**で利用する具体例を示します。

---

```java
import java.util.function.*;

public class LambdaDemo {
    public static void main(String[] args) {
        // Predicate<T> : T型の値を受け取り、booleanを返す
        Predicate<String> isEmpty = s -> s.isEmpty();
        System.out.println(isEmpty.test("")); // true

        // Consumer<T> : T型の値を受け取り、何も返さない
        Consumer<String> printer = s -> System.out.println("出力: " + s);
        printer.accept("Hello!"); // 出力: Hello!

        // Supplier<T> : 引数なしでT型の値を返す
        Supplier<Double> randomSupplier = () -> Math.random();
        System.out.println(randomSupplier.get()); // 例: 0.1234...

        // Function<T, R> : T型を受け取り、R型を返す
        Function<String, Integer> stringLength = s -> s.length();
        System.out.println(stringLength.apply("Java")); // 4

        // UnaryOperator<T> : T型を受け取り、T型を返す（Function<T,T>の特化型）
        UnaryOperator<String> toUpper = s -> s.toUpperCase();
        System.out.println(toUpper.apply("lambda")); // LAMBDA

        // BinaryOperator<T> : 2つのT型を受け取り、T型を返す（Function<T,T,T>の特化型）
        BinaryOperator<Integer> sum = (a, b) -> a + b;
        System.out.println(sum.apply(3, 5)); // 8

        // BiFunction<T, U, R> : 2つの任意型を受けてR型を返す
        BiFunction<String, String, Integer> concatLength = (a, b) -> (a + b).length();
        System.out.println(concatLength.apply("hello", "world")); // 10

        // BiPredicate<T, U> : 2つの任意型を受けてbooleanで判定
        BiPredicate<Integer, Integer> isSumTen = (a, b) -> a + b == 10;
        System.out.println(isSumTen.test(3, 7)); // true

        // BiConsumer<T, U> : 2つの値を受けて何も返さない
        BiConsumer<String, Integer> showLength = (str, len) -> System.out.println(str + " の長さ: " + len);
        showLength.accept("Test", 4); // Test の長さ: 4
    }
}
```


---

### 解説
- **ラムダ式**は「`(引数) -> 処理`」の形で関数型インタフェースにマッチします。
- 各例を`main`メソッドで実行すると、その場でラムダ式を利用する書き方になります。
- 例えば `Predicate<String>` は `.test()`、`Function<T, R>` は `.apply()` で呼び出します。

もし特定の用途（フィルター処理やMap操作など）が知りたい場合も、気軽にお知らせください！
