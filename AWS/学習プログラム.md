# AWS学習プログラム（無料枠/低コスト運用 + Java Lambda + IaC（CDK/Gradle）+ Cognito認証）

前提：
- リージョン：東京（ap-northeast-1）
- 目的：目標未定でも継続的に学べるように、事故（想定外課金・削除漏れ・権限ミス）を減らしつつ、サーバレス〜インフラ〜DB〜認証〜IaCまで段階的に習得する
- 開発環境：IntelliJ IDEA（macOS ARM64）
- 言語：Java（ローカルSDKは24でも可、Lambdaは原則 Java 21 をターゲットにするのが安全）

---

## 1. 無料（または低コスト）で学習するための大原則

AWSの無料枠には主に2種類があります。

- 常時無料（Always Free）：アカウント保有中、毎月一定量まで無料
- 12か月無料（12 Months Free）：新規アカウント作成から12か月間のみ一定量まで無料

注意：
- 「無料＝無制限」ではありません。上限を超えると課金されます。
- 無料枠対象外のサービスもあります。

---

## 2. 事故防止（最優先）：請求ガードとセキュリティ

継続学習では「触らない月」に止め忘れ事故が起きがちです。最初に必ず設定します。

### 2.1 AWS Budgets（予算）
- 月額上限を少額に設定し、メール通知（例：50% / 80% / 100%）

### 2.2 請求アラート
- 可能なら請求アラートも有効化し、早期検知を強化

### 2.3 MFA（多要素認証）
- ルートユーザーに MFAを必ず設定
- 普段の作業はルートユーザーではなく、IAMユーザー/ロールで行う

### 2.4 リージョン固定
- 最初は東京リージョンのみで運用（資源が散らばると削除漏れが増える）

---

## 3. アカウント作成（画面操作ベース）

### 3.1 事前準備
- メール：<your-email@example.com>
- 電話番号（SMS/音声）
- 支払い方法（本人確認で必要になることが多い）
- MFA用アプリ（TOTP対応）

### 3.2 サインアップ（作成）
1. AWS公式サイトへ → 「AWSアカウントを作成」
2. ルート用メールとアカウント名を入力
3. ルートパスワード設定（使い回さない）
4. 住所/連絡先入力
5. 支払い情報登録
6. 電話認証
7. サポートプランは学習用途なら通常 Basic
8. メール確認が来たら有効化 → ログイン

### 3.3 初回ログイン後に必ずやること
1. ルートに MFA設定
2. IAMで普段使いユーザーを作成（管理作業用）
3. Budgets/請求アラート設定
4. 右上リージョンを Tokyo に固定

---

## 4. 学習の推奨ロードマップ（事故りにくい順）

### Phase A（基礎・安全）
- IAM / S3 / CloudWatch（ログと権限の基礎）

### Phase B（サーバレス最短）
- Lambda + API Gateway + DynamoDB（低コストで「動くもの」）

### Phase C（インフラ入門）
- VPC + EC2（止め忘れ対策込みで「触った日に削除」）

### Phase D（DB拡張）
- RDS（必要になってから。継続課金になりやすい）

### Phase E（機械学習）
- まずはローカル学習→推論のみAWSなど、コストが出にくい使い方から

---

## 5. 課金事故の典型と回避策（チェックリスト）

- EC2の止め忘れ → 学習後は原則Terminate（削除）
- EBS/スナップショットが残る → インスタンス削除後に必ず確認
- NAT Gateway / Load Balancer → 最初は作らない（作ったら確実に削除）
- CloudWatch Logs出しすぎ → 学習ではログ量を抑える

毎回の終了時チェック：
- EC2 / EBS / RDS / NAT Gateway / Load Balancer / ML系エンドポイント / CloudWatch Logs

---

# Part I：サーバレス（Java）を“まず動かす”（Gradle）

このパートでは API Gateway HTTP API → Lambda(Java) → DynamoDB を最小構成で作ります。

## 6. DynamoDB テーブル作成（コンソール）
1. DynamoDB → Tables → Create a table
2. 例：
    - Table name：Memo
    - Partition key：memoId（String）
3. ステータスが `ACTIVE` になればOK

---

## 7. Lambda 関数作成（コンソール）
1. Lambda → Create function → Author from scratch
2. 例：
    - Function name：MemoApi
    - Runtime：Java 21
    - Architecture：arm64
3. 実行ロールは自動作成でOK（後で権限追加）

---

## 8. Lambda 実行ロールにDynamoDB権限を付与（最小）
- 対象は Memo テーブル
- アクションはまず dynamodb:GetItem, dynamodb:PutItem

※まず動かす段階では広めに付けてしまいがちですが、落ち着いたら最小権限へ絞るのが安全です。

---

## 9. Lambda環境変数（コンソール）
Lambda MemoApi → Configuration → Environment variables
- TABLE_NAME = Memo

---

## 10. Java Lambda（Gradle）プロジェクト構成

推奨：
- ローカルSDKはJava 24でもOK
- ビルド成果物はLambda互換のため Java 21 ターゲットにする

### 10.1 build.gradle（例）
- fat jarを作るため shadow を使用
- 依存：
    - aws-lambda-java-core
    - aws-lambda-java-events（HTTP API v2イベント/レスポンス）
    - AWS SDK v2 DynamoDB
    - Jackson

```textmate
plugins {
  id 'java'
  id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'com.example'
version = '1.0.0'

java {
  toolchain {
    languageVersion = JavaLanguageVersion.of(21)
  }
}

repositories {
  mavenCentral()
}

dependencies {
  implementation 'com.amazonaws:aws-lambda-java-core:1.2.3'
  implementation 'com.amazonaws:aws-lambda-java-events:3.11.5'
  implementation 'software.amazon.awssdk:dynamodb:2.29.52'
  implementation 'com.fasterxml.jackson.core:jackson-databind:2.18.2'

  testImplementation 'org.junit.jupiter:junit-jupiter:5.10.5'
}

tasks.test {
  useJUnitPlatform()
}

tasks.shadowJar {
  archiveClassifier.set('')
}
```


### 10.2 ハンドラ（HTTP API v2 + DynamoDB Put/Get）
- POST /memo：{"memoId":"<id>","text":"<text>"} を保存
- GET /memo?memoId=<id>：取得

（コードは前回提示の MemoHandler を使用）

---

## 11. ビルド（Gradle）→ Lambdaへアップロード

fat jar作成：

```shell script
./gradlew clean shadowJar
```


生成物例：
- build/libs/<artifact>-<version>.jar（classifierなし）

Lambdaコンソールで：
- Upload from → .jar
- Handler：com.example.MemoHandler::handleRequest

---

## 12. API Gateway（HTTP API）作成→Lambda接続（コンソール）
1. API Gateway → Create API → HTTP API
2. Integration：Lambda（MemoApi）
3. Routes：
    - GET /memo
    - POST /memo
4. Deploy（Stage例：dev）
5. Invoke URLを控える

---

## 13. 動作確認（疎通→ログ）
- POST：{"memoId":"1","text":"hello"}
- GET：/memo?memoId=1

CloudWatch Logsで確認：
- Lambda → Monitor → View logs in CloudWatch

---

# Part II：IaC（AWS CDK / Java / Gradle）で自動化 + Cognito JWT認証

ここからは「全部をコードで作る」「認証必須APIにする」を実現します。

## 14. 採用アーキテクチャ
- IaC：AWS CDK（Java）
- API：API Gateway HTTP API
- 認証：Cognito User Pool + JWT Authorizer
- 実行：Lambda（Java）
- DB：DynamoDB

メリット：
- cdk deploy で一括作成
- cdk destroy で一括削除（削除漏れ防止）

---

## 15. CDK（Java/Gradle）プロジェクト作成

```shell script
mkdir memo-iac
cd memo-iac
cdk init app --language java
```


CDKは「CLIがNode.js依存」である点に注意（アプリはJava）。

---

## 16. Lambda jarの配置（CDKプロジェクト側）
CDKプロジェクト直下に lambda/ を作り、Lambdaのfat jarを配置します。

```shell script
mkdir -p lambda
cp <path-to-your-lambda-fat-jar>.jar ./lambda/
```


---

## 17. CDK Stack（DynamoDB + Lambda + Cognito + HTTP API + Outputs）
Stackで作るもの：
- DynamoDB Memo（PAY_PER_REQUEST）
- Lambda MemoApi（Java 21 / arm64、TABLE_NAMEを環境変数で注入）
- Cognito User Pool（emailでサインイン）
- HTTP API（/memo GET/POST、JWT必須）
- Outputs（API URL、UserPoolId、ClientId、Issuer）

（コードは前回提示の MemoApiStack 相当を使用。Outputsを含める）

---

## 18. デプロイ（東京リージョン）

リージョンを東京に固定：

```shell script
export AWS_REGION=ap-northeast-1
export AWS_DEFAULT_REGION=ap-northeast-1
```


初回のみ：

```shell script
cdk bootstrap
```


デプロイ：

```shell script
cdk deploy
```


Outputsとして以下が得られます：
- ApiEndpoint
- UserPoolId
- UserPoolClientId
- JwtIssuer

---

## 19. Cognito：ユーザー作成 → JWT取得 → API呼び出し（学習用最短）

学習を最短化するため、管理者作成で進めます（値はプレースホルダー）。

### 19.1 ユーザー作成（仮パスワード）
```shell script
aws cognito-idp admin-create-user \
  --user-pool-id <your-user-pool-id> \
  --username <your-email@example.com> \
  --user-attributes Name=email,Value=<your-email@example.com> Name=email_verified,Value=true \
  --temporary-password <temporary-password> \
  --message-action SUPPRESS
```


### 19.2 初回パスワード変更（NEW_PASSWORD_REQUIRED対応）
```shell script
SESSION=$(aws cognito-idp admin-initiate-auth \
  --user-pool-id <your-user-pool-id> \
  --client-id <your-user-pool-client-id> \
  --auth-flow ADMIN_NO_SRP_AUTH \
  --auth-parameters USERNAME=<your-email@example.com>,PASSWORD=<temporary-password> \
  --query 'Session' --output text)

aws cognito-idp admin-respond-to-auth-challenge \
  --user-pool-id <your-user-pool-id> \
  --client-id <your-user-pool-client-id> \
  --challenge-name NEW_PASSWORD_REQUIRED \
  --challenge-responses USERNAME=<your-email@example.com>,NEW_PASSWORD=<new-password> \
  --session "$SESSION"
```


レスポンス内の AuthenticationResult.IdToken を控えます。

### 19.3 API呼び出し（Bearer）
```shell script
curl -sS -X POST \
  "<api-endpoint>/memo" \
  -H "Authorization: Bearer <id-token>" \
  -H "Content-Type: application/json" \
  -d '{"memoId":"1","text":"hello"}'
```


```shell script
curl -sS -X GET \
  "<api-endpoint>/memo?memoId=1" \
  -H "Authorization: Bearer <id-token>"
```


---

## 20. 片付け（IaCの強み）
```shell script
cdk destroy
```


---

# Part III：次のステップ

## 21. 次のステップ1：認可（Authorization）— ユーザーごとにデータ分離

目的：
- 「認証できた」だけでは不十分で、誰がどのデータにアクセスできるか（認可）が重要

進め方（方針）：
- JWTのクレーム（ユーザーID相当）を取り出す
- DynamoDBのキー設計を ownerId + memoId のように変更し、本人のデータのみ扱う
- APIは ownerId をクライアントから受け取らず、サーバ側で決定する

成果：
- “ログインしているユーザーのメモだけ見える” APIになる

---

## 22. 次のステップ2：IaC強化 — ビルド→配置→デプロイを1コマンド化

目的：
- Lambda jarのコピーを手作業にするとミスが出やすい
- いつでも再現できる状態（再現性）を高める

進め方（方針）：
- Gradleで「LambdaのshadowJar作成 → CDK側lambda/へコピー → cdk deploy」をタスク化
- Jar名を固定し、複数Jar混在を避ける

成果：
- ./gradlew deploy のような形で環境を更新できる

---

## 23. 次のステップ3：運用 — ログ/アラーム/コストガードをテンプレ化

目的：
- 「触って終わり」ではなく、安全に継続できる状態にする

進め方（方針）：
- API/Lambdaのエラー率、レイテンシーのアラーム（CloudWatch）
- ログ保持期間を短めにして学習で膨らませない
- Budgets通知の閾値・通知先の整備

成果：
- “壊れても気づける・課金にも気づける” 学習環境になる

---

## 付録：インフラ入門（VPC + EC2）をやるときの最短ルール
- デフォルトVPCでEC2起動 → 観察（SG/ルート等）→ Terminate
- EBS/スナップショット/Elastic IPが残っていないか確認
- NAT Gateway / Load Balancerは最初は作らない

---

## 付録：トラブルシュートの最短観点
- 401：AuthorizationヘッダのBearer、Issuer/Audience不一致
- 403/AccessDenied：Lambda実行ロールのDynamoDB権限
- 404：API Gatewayのルート/パスの不一致
- 500：Lambda例外（CloudWatch Logsで原因確認）
- ResourceNotFound：テーブル名/リージョン違い、環境変数ミス