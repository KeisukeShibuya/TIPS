# AWS学習プログラム（無料枠/低コスト運用 + Java Lambda + IaC（CDK/Gradle）+ Cognito認証）

## 目次

- [1. 無料（または低コスト）で学習するための大原則](#1-無料または低コストで学習するための大原則)
- [2. 事故防止（最優先）：請求ガードとセキュリティ](#2-事故防止最優先請求ガードとセキュリティ)
    - [2.1 AWS Budgets（予算）](#21-aws-budgets予算)
    - [2.2 請求アラート](#22-請求アラート)
    - [2.3 MFA（多要素認証）](#23-mfa多要素認証)
    - [2.4 リージョン固定](#24-リージョン固定)
- [3. アカウント作成（画面操作ベース）](#3-アカウント作成画面操作ベース)
    - [3.1 事前準備](#31-事前準備)
    - [3.2 サインアップ（作成）](#32-サインアップ作成)
    - [3.3 初回ログイン後に必ずやること](#33-初回ログイン後に必ずやること)
- [4. 学習の推奨ロードマップ（事故りにくい順）](#4-学習の推奨ロードマップ事故りにくい順)
    - [Phase A（基礎・安全）](#phase-a基礎安全)
    - [Phase B（サーバレス最短）](#phase-bサーバレス最短)
    - [Phase C（インフラ入門）](#phase-cインフラ入門)
    - [Phase D（DB拡張）](#phase-ddb拡張)
    - [Phase E（機械学習）](#phase-e機械学習)
- [5. 課金事故の典型と回避策（チェックリスト）](#5-課金事故の典型と回避策チェックリスト)
- [Part I：サーバレス（Java）を“まず動かす”（Gradle）](#part-iサーバレスjavaをまず動かすgradle)
    - [6. DynamoDB テーブル作成（コンソール）](#6-dynamodb-テーブル作成コンソール)
    - [7. Lambda 関数作成（コンソール）](#7-lambda-関数作成コンソール)
    - [8. Lambda 実行ロールにDynamoDB権限を付与（最小）](#8-lambda-実行ロールにdynamodb権限を付与最小)
    - [9. Lambda環境変数（コンソール）](#9-lambda環境変数コンソール)
    - [10. Java Lambda（Gradle）プロジェクト構成](#10-java-lambda-gradleプロジェクト構成)
    - [11. ビルド（Gradle）→ Lambdaへアップロード](#11-ビルドgradle-lambdaへアップロード)
    - [12. API Gateway（HTTP API）作成→Lambda接続（コンソール）](#12-api-gatewayhttp-api作成lambda接続コンソール)
    - [13. 動作確認（疎通→ログ）](#13-動作確認疎通ログ)
- [Part II：IaC（AWS CDK / Java / Gradle）で自動化 + Cognito JWT認証](#part-iiiacaws-cdk--java--gradleで自動化--cognito-jwt認証)
    - [14. 採用アーキテクチャ](#14-採用アーキテクチャ)
    - [15. CDK（Java/Gradle）プロジェクト作成](#15-cdkjavagradleプロジェクト作成)
    - [16. Lambda jarの配置（CDKプロジェクト側）](#16-lambda-jarの配置cdkプロジェクト側)
    - [17. CDK Stack（DynamoDB + Lambda + Cognito + HTTP API + Outputs）](#17-cdk-stackdynamodb--lambda--cognito--http-api--outputs)
    - [18. デプロイ（東京リージョン）](#18-デプロイ東京リージョン)
    - [19. Cognito：ユーザー作成 → JWT取得 → API呼び出し（学習用最短）](#19-cognitoユーザー作成--jwt取得--api呼び出し学習用最短)
    - [20. 片付け（IaCの強み）](#20-片付けiacの強み)
- [Part III：次のステップ](#part-iii次のステップ)
    - [21. 次のステップ1：認可（Authorization）— ユーザーごとにデータ分離](#21-次のステップ1認可authorization-ユーザーごとにデータ分離)
    - [22. 次のステップ2：IaC強化 — ビルド→配置→デプロイを1コマンド化](#22-次のステップ2iac強化--ビルド配置デプロイを1コマンド化)
    - [23. 次のステップ3：運用 — ログ/アラーム/コストガードをテンプレ化](#23-次のステップ3運用--ログアラームコストガードをテンプレ化)
    - [付録：インフラ入門（VPC + EC2）をやるときの最短ルール](#付録インフラ入門vpc--ec2をやるときの最短ルール)
    - [付録：トラブルシュートの最短観点](#付録トラブルシュートの最短観点)

---

前提：
- リージョン：東京（ap-northeast-1）
- 目的：目標未定でも継続的に学べるように、事故（想定外課金・削除漏れ・権限ミス）を減らしつつ、サーバレス〜インフラ〜DB〜認証〜IaCまで段階的に習得する
- 開発環境：IntelliJ IDEA（macOS ARM64）
- 言語：Java（JDK 25 を使用する）

---

## 1. 無料（または低コスト）で学習するための大原則

AWSの無料枠には主に2種類があります。

- 常時無料（Always Free）：アカウント保有中、毎月一定量まで無料
- 12か月無料（12 Months Free）：新規アカウント作成から12か月間のみ一定量まで無料

注意：
- 「無料＝無制限」ではありません。上限を超えると課金されます。
- 無料枠対象外のサービスもあります。

---

## 2. 事故防止（最優先）：請求ガードとセキュリティ

継続学習では「触らない月」に止め忘れ事故が起きがちです。最初に必ず設定します。

### 2.1 AWS Budgets（予算）
- 月額上限を少額に設定し、メール通知（例：50% / 80% / 100%）

### 2.2 請求アラート
- 可能なら請求アラートも有効化し、早期検知を強化

### 2.3 MFA（多要素認証）
- ルートユーザーに MFAを必ず設定
- 普段の作業はルートユーザーではなく、IAMユーザー/ロールで行う

### 2.4 リージョン固定
- 最初は東京リージョンのみで運用（資源が散らばると削除漏れが増える）

---

## 3. アカウント作成（画面操作ベース）

### 3.1 事前準備
- メール：<your-email@example.com>
- 電話番号（SMS/音声）
- 支払い方法（本人確認で必要になることが多い）
- MFA用アプリ（TOTP対応）

### 3.2 サインアップ（作成）
1. AWS公式サイトへ → 「AWSアカウントを作成」
2. ルート用メールとアカウント名を入力
3. ルートパスワード設定（使い回さない）
4. 住所/連絡先入力
5. 支払い情報登録
6. 電話認証
7. サポートプランは学習用途なら通常 Basic
8. メール確認が来たら有効化 → ログイン

### 3.3 初回ログイン後に必ずやること
1. ルートに MFA設定
2. IAMで普段使いユーザーを作成（管理作業用）
3. Budgets/請求アラート設定
4. 右上リージョンを Tokyo に固定

---

## 4. 学習の推奨ロードマップ（事故りにくい順）

### Phase A（基礎・安全）
- IAM / S3 / CloudWatch（ログと権限の基礎）

### Phase B（サーバレス最短）
- Lambda + API Gateway + DynamoDB（低コストで「動くもの」）

### Phase C（インフラ入門）
- VPC + EC2（止め忘れ対策込みで「触った日に削除」）

### Phase D（DB拡張）
- RDS（必要になってから。継続課金になりやすい）

### Phase E（機械学習）
- まずはローカル学習→推論のみAWSなど、コストが出にくい使い方から

---

## 5. 課金事故の典型と回避策（チェックリスト）

- EC2の止め忘れ → 学習後は原則Terminate（削除）
- EBS/スナップショットが残る → インスタンス削除後に必ず確認
- NAT Gateway / Load Balancer → 最初は作らない（作ったら確実に削除）
- CloudWatch Logs出しすぎ → 学習ではログ量を抑える

毎回の終了時チェック：
- EC2 / EBS / RDS / NAT Gateway / Load Balancer / ML系エンドポイント / CloudWatch Logs

---

# Part I：サーバレス（Java）を“まず動かす”（Gradle）

このパートでは API Gateway HTTP API → Lambda(Java) → DynamoDB を最小構成で作ります。

## 6. DynamoDB テーブル作成（コンソール）
1. **DynamoDB** → **Tables(テーブル)** → **Create a table(テーブルの作成)**
2. 例：
    - Table name：Memo
    - Partition key：memoId（String）
3. ステータスが `ACTIVE` になればOK

---

## 7. Lambda 関数作成（コンソール）
1. **Lambda** → **Create function(関数を作成)** → **Author from scratch(一から作成)**
2. 例：
    - Function name：MemoApi
    - Runtime：Java 25
    - Architecture：arm64
3. 実行ロールは自動作成でOK（後で権限追加）

---

## 8. Lambda 実行ロールにDynamoDB権限を付与（最小）
- 対象は Memo テーブル
- アクションはまず dynamodb:GetItem, dynamodb:PutItem

※まず動かす段階では広めに付けてしまいがちですが、落ち着いたら最小権限へ絞るのが安全です。

### 1) Lambda から「実行ロール」を開く

1. AWS コンソールで **Lambda** を開く
2. 対象の関数(`MemoApi`)をクリック
3. **Configuration(設定)タブ** → **Permissions(アクセス権限)**
4. **Execution role(実行ロール)** のリンクをクリック
  * ここで IAM のロール画面に遷移します

### 2) IAM ロールに「インラインポリシー」を追加する

1. 遷移先の IAM ロール画面で **Permissions(許可)** タブを開く
2. **Add permissions(許可を追加)** → **Create inline policy(インラインポリシーを作成)**
3. エディタで **ビジュアル** タブを選択(※) →　以下を入力 → **Next(次へ)**
   - サービス：DynamoDB
   - アクション許可：GetItem, PutItem
   - リソース：`arn:aws:dynamodb:ap-northeast-1:<account-id>:table/Memo`
     - **ARN を追加** から設定
4. **Policy name(ポリシー名)** を入力 (例：`MemoTableGetPut`)
5. **Create policy(ポリシーの作成)** を押して保存

#### ※ポリシーエディタにJSONを選択した場合

以下のポリシーを貼り付け
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "MemoTableGetPut",
      "Effect": "Allow",
      "Action": [
        "dynamodb:GetItem",
        "dynamodb:PutItem"
      ],
      "Resource": "arn:aws:dynamodb:ap-northeast-1:<account-id>:table/Memo"
    }
  ]
}
```

---

## 9. Lambda環境変数（コンソール）
Lambda MemoApi → Configuration(設定) → Environment variables(環境変数)
- TABLE_NAME = Memo

---

## 10. Java Lambda（Gradle）プロジェクト構成

推奨：
- Java 25 / Gradle

### 10.1 build.gradle（例）
- fat jarを作るため shadow を使用
- 依存：
    - aws-lambda-java-core
    - aws-lambda-java-events（HTTP API v2イベント/レスポンス）
    - AWS SDK v2 DynamoDB
    - Jackson

```groovy
plugins {
  id 'java'
  id 'com.gradleup.shadow' version '9.3.0'
}

group = 'com.example'
version = '1.0.0'

java {
  toolchain {
    languageVersion = JavaLanguageVersion.of(25)
  }
}

repositories {
  mavenCentral()
}

dependencies {
  implementation 'com.amazonaws:aws-lambda-java-core:1.4.0'
  implementation 'com.amazonaws:aws-lambda-java-events:3.16.1'
  implementation 'software.amazon.awssdk:dynamodb:2.41.1'
  implementation 'tools.jackson.core:jackson-databind:3.0.3'

  testImplementation 'org.junit.jupiter:junit-jupiter:6.0.1'
}

tasks.test {
  useJUnitPlatform()
}

tasks.shadowJar {
  archiveClassifier.set('')
}
```


### 10.2 ハンドラ（HTTP API v2 + DynamoDB Put/Get）
- POST /memo：{"memoId":"<id>","text":"<text>"} を保存
- GET /memo?memoId=<id>：取得
- DynamoDB テーブル名は環境変数 `TABLE_NAME` から取得

```java
package com.example;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse;
import tools.jackson.databind.JsonNode;
import tools.jackson.databind.ObjectMapper;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.dynamodb.DynamoDbClient;
import software.amazon.awssdk.services.dynamodb.model.AttributeValue;
import software.amazon.awssdk.services.dynamodb.model.GetItemRequest;
import software.amazon.awssdk.services.dynamodb.model.GetItemResponse;
import software.amazon.awssdk.services.dynamodb.model.PutItemRequest;

import java.util.HashMap;
import java.util.Map;

public class MemoHandler implements RequestHandler<APIGatewayV2HTTPEvent, APIGatewayV2HTTPResponse> {

  private static final ObjectMapper MAPPER = new ObjectMapper();
  private static final String TABLE_NAME = System.getenv("TABLE_NAME");

  // 学習の分かりやすさ優先で東京固定（将来は環境変数から読む形でもOK）
  private static final DynamoDbClient DDB = DynamoDbClient.builder()
      .region(Region.AP_NORTHEAST_1)
      .build();

  @Override
  public APIGatewayV2HTTPResponse handleRequest(APIGatewayV2HTTPEvent event, Context context) {
    String method = event.getRequestContext() != null && event.getRequestContext().getHttp() != null
        ? event.getRequestContext().getHttp().getMethod()
        : "UNKNOWN";
    String path = event.getRawPath();

    context.getLogger().log("method=" + method + " path=" + path);

    try {
      if (TABLE_NAME == null || TABLE_NAME.isBlank()) {
        return json(500, Map.of("message", "TABLE_NAME is not set"));
      }

      if ("GET".equals(method) && "/memo".equals(path)) {
        return handleGet(event);
      }
      if ("POST".equals(method) && "/memo".equals(path)) {
        return handlePost(event);
      }

      return json(404, Map.of("message", "not found"));
    } catch (Exception e) {
      context.getLogger().log("error=" + e);
      return json(500, Map.of("message", "internal error"));
    }
  }

  private APIGatewayV2HTTPResponse handleGet(APIGatewayV2HTTPEvent event) {
    String memoId = null;
    if (event.getQueryStringParameters() != null) {
      memoId = event.getQueryStringParameters().get("memoId");
    }
    if (memoId == null || memoId.isBlank()) {
      return json(400, Map.of("message", "memoId query parameter is required"));
    }

    GetItemResponse res = DDB.getItem(GetItemRequest.builder()
        .tableName(TABLE_NAME)
        .key(Map.of("memoId", AttributeValue.builder().s(memoId).build()))
        .consistentRead(false)
        .build());

    if (!res.hasItem() || res.item().isEmpty()) {
      return json(404, Map.of("message", "not found", "memoId", memoId));
    }

    Map<String, AttributeValue> item = res.item();
    String text = item.containsKey("text") ? item.get("text").s() : "";

    return json(200, Map.of("memoId", memoId, "text", text));
  }

  private APIGatewayV2HTTPResponse handlePost(APIGatewayV2HTTPEvent event) {
    String body = event.getBody();
    if (body == null || body.isBlank()) {
      return json(400, Map.of("message", "request body is required"));
    }

    JsonNode root = MAPPER.readTree(body);
    String memoId = root.hasNonNull("memoId") ? root.get("memoId").asString() : null;
    String text = root.hasNonNull("text") ? root.get("text").asString() : null;

    if (memoId == null || memoId.isBlank()) {
      return json(400, Map.of("message", "memoId is required"));
    }

    Map<String, AttributeValue> item = new HashMap<>();
    item.put("memoId", AttributeValue.builder().s(memoId).build());
    if (text != null) {
      item.put("text", AttributeValue.builder().s(text).build());
    }

    DDB.putItem(PutItemRequest.builder()
        .tableName(TABLE_NAME)
        .item(item)
        .build());

    return json(200, Map.of("message", "saved", "memoId", memoId));
  }

  private APIGatewayV2HTTPResponse json(int status, Map<String, Object> body) {
    return APIGatewayV2HTTPResponse.builder()
        .withStatusCode(status)
        .withHeaders(Map.of("content-type", "application/json; charset=utf-8"))
        .withBody(MAPPER.writeValueAsString(body))
        .build();
  }
}
```

---

## 11. ビルド（Gradle）→ Lambdaへアップロード

fat jar作成：

```shell script
./gradlew clean shadowJar
```


生成物例：
- build/libs/<artifact>-<version>.jar（classifierなし）

Lambdaコンソール( `MemoApi` )のコードタブで：
- アップロード元 → .jar
- ランタイム設定 ハンドラ：com.example.MemoHandler::handleRequest

---

## 12. API Gateway（HTTP API）作成→Lambda接続（コンソール）
1. API Gateway → API を作成 → HTTP API
2. API を設定
    - API 名：(任意)
    - IP アドレスのタイプ：IPv4
    - 統合：
      * Lambda
      * AWS リージョン： ap-northeast-1
      * Lambda 関数： MemoApiのARN
      * バージョン：2.0
3. ルートを設定：
    - GET /memo
    - POST /memo
4. ステージを定義：
   - ステージを追加する場合の名称例：dev

---

## 13. 動作確認（疎通→ログ）
- POST：{"memoId":"1","text":"hello"}
- GET：/memo?memoId=1

### コマンドでの確認例

- POST
    ```shell script
    curl -i -X POST \
      "https://f5i2hzdxuh.execute-api.ap-northeast-1.amazonaws.com/memo" \
      -H "Content-Type: application/json" \
      -d '{"memoId":"1","text":"hello"}'
    ```
- GET
    ```shell script
    curl -i -X GET \
      "https://f5i2hzdxuh.execute-api.ap-northeast-1.amazonaws.com/memo?memoId=1" 
    ```

CloudWatch Logsで確認：
- Lambda → Monitor → View logs in CloudWatch

---

# Part II：IaC（AWS CDK / Java / Gradle）で自動化 + Cognito JWT認証

ここからは「全部をコードで作る」「認証必須APIにする」を実現します。

## 14. 採用アーキテクチャ
- IaC：AWS CDK（Java）
- API：API Gateway HTTP API
- 認証：Cognito User Pool + JWT Authorizer
- 実行：Lambda（Java）
- DB：DynamoDB

メリット：
- cdk deploy で一括作成
- cdk destroy で一括削除（削除漏れ防止）

---

## 15. CDK（Java/Gradle）プロジェクト作成

```shell script
mkdir memo-iac
cd memo-iac
cdk init app --language java
```


CDKは「CLIがNode.js依存」である点に注意（アプリはJava）。

---

## 16. Lambda jarの配置（CDKプロジェクト側）
CDKプロジェクト直下に lambda/ を作り、Lambdaのfat jarを配置します。

```shell script
mkdir -p lambda
cp <path-to-your-lambda-fat-jar>.jar ./lambda/
```


---

## 17. CDK Stack（DynamoDB + Lambda + Cognito + HTTP API + Outputs）
Stackで作るもの：
- DynamoDB Memo（PAY_PER_REQUEST）
- Lambda MemoApi（Java 25 / arm64、TABLE_NAMEを環境変数で注入）
- Cognito User Pool + App Client（シークレットなし）
- HTTP API（/memo GET/POST、JWT必須）
- Outputs（API URL、UserPoolId、ClientId、Issuer）

```java
package com.example;

import java.util.List;
import java.util.Map;

import software.amazon.awscdk.CfnOutput;
import software.amazon.awscdk.Duration;
import software.amazon.awscdk.Stack;
import software.amazon.awscdk.StackProps;

import software.amazon.awscdk.services.apigatewayv2.HttpApi;
import software.amazon.awscdk.services.apigatewayv2.HttpMethod;
import software.amazon.awscdk.services.apigatewayv2.PayloadFormatVersion;

import software.amazon.awscdk.services.apigatewayv2.authorizers.HttpJwtAuthorizer;
import software.amazon.awscdk.services.apigatewayv2.authorizers.HttpJwtAuthorizerIdentitySource;
import software.amazon.awscdk.services.apigatewayv2.authorizers.HttpJwtAuthorizerProps;
import software.amazon.awscdk.services.apigatewayv2.integrations.HttpLambdaIntegration;

import software.amazon.awscdk.services.cognito.SignInAliases;
import software.amazon.awscdk.services.cognito.UserPool;
import software.amazon.awscdk.services.cognito.UserPoolClient;

import software.amazon.awscdk.services.dynamodb.Attribute;
import software.amazon.awscdk.services.dynamodb.AttributeType;
import software.amazon.awscdk.services.dynamodb.BillingMode;
import software.amazon.awscdk.services.dynamodb.Table;

import software.amazon.awscdk.services.iam.Effect;
import software.amazon.awscdk.services.iam.PolicyStatement;

import software.amazon.awscdk.services.lambda.Architecture;
import software.amazon.awscdk.services.lambda.Code;
import software.amazon.awscdk.services.lambda.Function;
import software.amazon.awscdk.services.lambda.Runtime;

import software.constructs.Construct;

public class MemoApiStack extends Stack {

  public MemoApiStack(final Construct scope, final String id, final StackProps props) {
    super(scope, id, props);

    // DynamoDB
    Table table = Table.Builder.create(this, "MemoTable")
        .tableName("Memo")
        .partitionKey(Attribute.builder()
            .name("memoId")
            .type(AttributeType.STRING)
            .build())
        .billingMode(BillingMode.PAY_PER_REQUEST)
        .build();

    // Lambda（Code.fromAsset("lambda") は「フォルダ」を指す：lambda/配下にfat jarを置く）
    Function memoFn = Function.Builder.create(this, "MemoFn")
        .functionName("MemoApi")
        .runtime(Runtime.JAVA_21)
        .architecture(Architecture.ARM_64)
        .handler("com.example.MemoHandler::handleRequest")
        .code(Code.fromAsset("lambda"))
        .timeout(Duration.seconds(10))
        .memorySize(512)
        .environment(Map.of(
            "TABLE_NAME", table.getTableName()
        ))
        .build();

    // DynamoDB権限（最小：Get/Put）
    memoFn.addToRolePolicy(PolicyStatement.Builder.create()
        .effect(Effect.ALLOW)
        .actions(List.of(
            "dynamodb:GetItem",
            "dynamodb:PutItem"
        ))
        .resources(List.of(table.getTableArn()))
        .build());

    // Cognito User Pool（学習用：emailでサインイン）
    UserPool userPool = UserPool.Builder.create(this, "UserPool")
        .userPoolName("MemoUsers")
        .selfSignUpEnabled(true)
        .signInAliases(SignInAliases.builder()
            .email(true)
            .build())
        .build();

    UserPoolClient userPoolClient = UserPoolClient.Builder.create(this, "UserPoolClient")
        .userPool(userPool)
        .generateSecret(false)
        .build();

    // HTTP API + JWT Authorizer（Cognito）
    // issuer: https://cognito-idp.<region>.amazonaws.com/<userPoolId>
    String issuer = "https://cognito-idp." + this.getRegion() + ".amazonaws.com/" + userPool.getUserPoolId();

    HttpJwtAuthorizer authorizer = new HttpJwtAuthorizer(this, "JwtAuthorizer",
        HttpJwtAuthorizerProps.builder()
            .jwtAudience(List.of(userPoolClient.getUserPoolClientId()))
            .jwtIssuer(issuer)
            .identitySource(List.of(HttpJwtAuthorizerIdentitySource.header("Authorization")))
            .build()
    );

    HttpApi api = HttpApi.Builder.create(this, "HttpApi")
        .apiName("MemoHttpApi")
        .build();

    HttpLambdaIntegration integration = HttpLambdaIntegration.Builder.create("MemoIntegration", memoFn)
        .payloadFormatVersion(PayloadFormatVersion.VERSION_2_0)
        .build();

    // ルート（JWT必須）
    api.addRoutes(r -> r
        .path("/memo")
        .methods(List.of(HttpMethod.GET))
        .integration(integration)
        .authorizer(authorizer)
    );

    api.addRoutes(r -> r
        .path("/memo")
        .methods(List.of(HttpMethod.POST))
        .integration(integration)
        .authorizer(authorizer)
    );

    // Outputs（デプロイ後の確認を楽にする）
    CfnOutput.Builder.create(this, "ApiEndpoint")
        .value(api.getApiEndpoint())
        .build();

    CfnOutput.Builder.create(this, "UserPoolId")
        .value(userPool.getUserPoolId())
        .build();

    CfnOutput.Builder.create(this, "UserPoolClientId")
        .value(userPoolClient.getUserPoolClientId())
        .build();

    CfnOutput.Builder.create(this, "JwtIssuer")
        .value(issuer)
        .build();
  }
}
```

---

## 18. デプロイ（東京リージョン）

リージョンを東京に固定：

```shell script
export AWS_REGION=ap-northeast-1
export AWS_DEFAULT_REGION=ap-northeast-1
```


初回のみ：

```shell script
cdk bootstrap
```


デプロイ：

```shell script
cdk deploy
```


Outputsとして以下が得られます：
- ApiEndpoint
- UserPoolId
- UserPoolClientId
- JwtIssuer

---

## 19. Cognito：ユーザー作成 → JWT取得 → API呼び出し（学習用最短）

学習を最短化するため、管理者作成で進めます（値はプレースホルダー）。

### 19.1 ユーザー作成（仮パスワード）
```shell script
aws cognito-idp admin-create-user \
  --user-pool-id <your-user-pool-id> \
  --username <your-email@example.com> \
  --user-attributes Name=email,Value=<your-email@example.com> Name=email_verified,Value=true \
  --temporary-password <temporary-password> \
  --message-action SUPPRESS
```


### 19.2 初回パスワード変更（NEW_PASSWORD_REQUIRED対応）
```shell script
SESSION=$(aws cognito-idp admin-initiate-auth \
  --user-pool-id <your-user-pool-id> \
  --client-id <your-user-pool-client-id> \
  --auth-flow ADMIN_NO_SRP_AUTH \
  --auth-parameters USERNAME=<your-email@example.com>,PASSWORD=<temporary-password> \
  --query 'Session' --output text)

aws cognito-idp admin-respond-to-auth-challenge \
  --user-pool-id <your-user-pool-id> \
  --client-id <your-user-pool-client-id> \
  --challenge-name NEW_PASSWORD_REQUIRED \
  --challenge-responses USERNAME=<your-email@example.com>,NEW_PASSWORD=<new-password> \
  --session "$SESSION"
```


レスポンス内の AuthenticationResult.IdToken を控えます。

### 19.3 API呼び出し（Bearer）
```shell script
curl -sS -X POST \
  "<api-endpoint>/memo" \
  -H "Authorization: Bearer <id-token>" \
  -H "Content-Type: application/json" \
  -d '{"memoId":"1","text":"hello"}'
```


```shell script
curl -sS -X GET \
  "<api-endpoint>/memo?memoId=1" \
  -H "Authorization: Bearer <id-token>"
```


---

## 20. 片付け（IaCの強み）
```shell script
cdk destroy
```


---

# Part III：次のステップ

## 21. 次のステップ1：認可（Authorization）— ユーザーごとにデータ分離

目的：
- 「認証できた」だけでは不十分で、誰がどのデータにアクセスできるか（認可）が重要

進め方（方針）：
- JWTのクレーム（ユーザーID相当）を取り出す
- DynamoDBのキー設計を ownerId + memoId のように変更し、本人のデータのみ扱う
- APIは ownerId をクライアントから受け取らず、サーバ側で決定する

成果：
- “ログインしているユーザーのメモだけ見える” APIになる

---

## 22. 次のステップ2：IaC強化 — ビルド→配置→デプロイを1コマンド化

目的：
- Lambda jarのコピーを手作業にするとミスが出やすい
- いつでも再現できる状態（再現性）を高める

進め方（方針）：
- Gradleで「LambdaのshadowJar作成 → CDK側lambda/へコピー → cdk deploy」をタスク化
- Jar名を固定し、複数Jar混在を避ける

成果：
- ./gradlew deploy のような形で環境を更新できる

### 実装パターンA：1つのリポジトリで `:lambda` と `:infra` (CDK) をマルチプロジェクト化

#### 目的

* `./gradlew deploy` で以下を自動実行
    1. Lambdaのfat jar（shadowJar）作成
    2. `infra/lambda/` にjarをコピー（CDKの [`Code.fromAsset("lambda")`](https://github.com/KeisukeShibuya/TIPS/blob/main/AWS/学習プログラム.md#L541) が拾う場所）
    3. `:infra:cdkDeploy` で CDK デプロイ

#### `settings.gradle` (ルート)

```groovy
rootProject.name = 'memo-system'
include('lambda', 'infra')
```

#### `lambda/build.gradle` (lambda側)
(shadowJarを作る設定)

```groovy
plugins {
  id 'java'
  id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = 'com.example'
version = '1.0.0'

java {
  toolchain {
    languageVersion = JavaLanguageVersion.of(21)
  }
}

repositories {
  mavenCentral()
}

dependencies {
  implementation 'com.amazonaws:aws-lambda-java-core:1.2.3'
  implementation 'com.amazonaws:aws-lambda-java-events:3.11.5'
  implementation 'software.amazon.awssdk:dynamodb:2.29.52'
  implementation 'com.fasterxml.jackson.core:jackson-databind:2.18.2'
}

tasks.shadowJar {
  archiveClassifier.set('')
}
```

#### `infra/build.gradle` (CDK側：Gradleで `cdk deploy` を叩く)

ポイント：
- CDK CLIはNode依存なので、Gradleからは**Exec**で `npx cdk` を呼ぶ
- `infra/lambda/` にコピーされたjarを**1つに固定**するため、コピー時に名前を固定する(例： `app.jar`)

```groovy
plugins {
  id 'java'
}

java {
  toolchain {
    languageVersion = JavaLanguageVersion.of(21)
  }
}

def lambdaJarFixedName = 'app.jar'
def lambdaAssetsDir = file("$projectDir/lambda")

tasks.register('prepareLambdaAsset', Copy) {
  dependsOn(':lambda:shadowJar')

  from(project(':lambda').tasks.named('shadowJar').map { it.archiveFile })
  into(lambdaAssetsDir)

  rename { lambdaJarFixedName } // jar名を固定して混乱を防止
}

tasks.register('cdkBootstrap', Exec) {
  workingDir projectDir
  environment 'AWS_REGION', (System.getenv('AWS_REGION') ?: 'ap-northeast-1')
  environment 'AWS_DEFAULT_REGION', (System.getenv('AWS_DEFAULT_REGION') ?: 'ap-northeast-1')

  commandLine 'npx', 'cdk', 'bootstrap'
}

tasks.register('cdkDeploy', Exec) {
  dependsOn('prepareLambdaAsset')
  workingDir projectDir
  environment 'AWS_REGION', (System.getenv('AWS_REGION') ?: 'ap-northeast-1')
  environment 'AWS_DEFAULT_REGION', (System.getenv('AWS_DEFAULT_REGION') ?: 'ap-northeast-1')

  commandLine 'npx', 'cdk', 'deploy'
}

tasks.register('cdkDestroy', Exec) {
  workingDir projectDir
  environment 'AWS_REGION', (System.getenv('AWS_REGION') ?: 'ap-northeast-1')
  environment 'AWS_DEFAULT_REGION', (System.getenv('AWS_DEFAULT_REGION') ?: 'ap-northeast-1')

  commandLine 'npx', 'cdk', 'destroy'
}
```

#### ルート `build.gradle` (ワンコマンドの入口)

```groovy
tasks.register('deploy') {
  dependsOn(':infra:cdkDeploy')
}

tasks.register('destroy') {
  dependsOn(':infra:cdkDestroy')
}

tasks.register('bootstrap') {
  dependsOn(':infra:cdkBootstrap')
}
```

#### 実行コマンド(ルートで)

```shell script
export AWS_REGION=ap-northeast-1
export AWS_DEFAULT_REGION=ap-northeast-1

./gradlew bootstrap
./gradlew deploy
./gradlew destroy
```

### 実装パターンB：リポジトリ分割(LambdaプロジェクトとCDKプロジェクトが別)

別リポジトリ/別ディレクトリでも、CDK側Gradleに**外部jarをコピーする**タスクを置けば同じことができる。

#### CDK側 `build.gradle` (例：`../lambda-app/` を参照してコピー)

```groovy
plugins {
  id 'java'
}

def lambdaProjectDir = file('../lambda-app')          // あなたの配置に合わせて変更
def lambdaJarPath = file("$lambdaProjectDir/build/libs/app.jar") // 生成物名に合わせて変更
def lambdaAssetsDir = file("$projectDir/lambda")

tasks.register('copyLambdaJar', Copy) {
  from(lambdaJarPath)
  into(lambdaAssetsDir)
}

tasks.register('cdkDeploy', Exec) {
  dependsOn('copyLambdaJar')
  workingDir projectDir
  environment 'AWS_REGION', (System.getenv('AWS_REGION') ?: 'ap-northeast-1')
  environment 'AWS_DEFAULT_REGION', (System.getenv('AWS_DEFAULT_REGION') ?: 'ap-northeast-1')

  commandLine 'npx', 'cdk', 'deploy'
}
```

---

## 23. 次のステップ3：運用 — ログ/アラーム/コストガードをテンプレ化

目的：
- 「触って終わり」ではなく、安全に継続できる状態にする

進め方（方針）：
- API/Lambdaのエラー率、レイテンシーのアラーム（CloudWatch）
- ログ保持期間を短めにして学習で膨らませない
- Budgets通知の閾値・通知先の整備

成果：
- “壊れても気づける・課金にも気づける” 学習環境になる

---

## 付録：インフラ入門（VPC + EC2）をやるときの最短ルール
- デフォルトVPCでEC2起動 → 観察（SG/ルート等）→ Terminate
- EBS/スナップショット/Elastic IPが残っていないか確認
- NAT Gateway / Load Balancerは最初は作らない

---

## 付録：トラブルシュートの最短観点
- 401：AuthorizationヘッダのBearer、Issuer/Audience不一致
- 403/AccessDenied：Lambda実行ロールのDynamoDB権限
- 404：API Gatewayのルート/パスの不一致
- 500：Lambda例外（CloudWatch Logsで原因確認）
- ResourceNotFound：テーブル名/リージョン違い、環境変数ミス